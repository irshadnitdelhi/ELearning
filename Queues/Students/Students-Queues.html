
<h1>Queues</h1>

<div class="element my-4"><h5>Introduction</h5><p>Queue is also an abstract data type or a linear data structure, just like stack data structure, in which the first element is inserted from one end called the REAR(also called tail), and the removal of existing element takes place from the other end called as FRONT(also called head).
    
    This makes queue as FIFO(First in First Out) data structure, which means that element inserted first will be removed first.</p></div><div class="element my-4"><h5>Basic Features</h5><p>
        Like stack, queue is also an ordered list of elements of similar data types.
        Queue is a FIFO( First in First Out ) structure.
        Once a new element is inserted into the Queue, all the elements inserted before the new element in the queue must be removed, to remove the new element.
        peek( ) function is oftenly used to return the value of first element without dequeuing it.
    </p></div><div class="element my-4"><h5>Operations</h5><pre style="font-family: consolas;">Queue operations may involve initializing or defining the queue, utilizing it, and then completely erasing it from the memory. Here we shall try to understand the basic operations associated with queues −
        
        enqueue() − add (store) an item to the queue.
        
        dequeue() − remove (access) an item from the queue.
    </pre></div><div class="element my-4"><h5>Code</h5><pre>/* Below program is written in C++ language */
        
        #include iostream
            
            using namespace std;
            
            #define SIZE 10
            
            class Queue
            {
                int a[SIZE];
                int rear;   //same as tail
                int front;  //same as head
                
                public:
                Queue()
                {
                    rear = front = -1;
                }
                
                //declaring enqueue, dequeue and display functions
                void enqueue(int x);     
                int dequeue();
                void display();
            };
            
            // function enqueue - to add data to queue
            void Queue :: enqueue(int x)
            {
                if(front == -1) {
                    front++;
                }
                if( rear == SIZE-1)
                {
                    cout &lt;&lt; "Queue is full";
                }
                else
                {
                    a[++rear] = x;
                }
            }
            
            // function dequeue - to remove data from queue
            int Queue :: dequeue()
            {
                return a[++front];  // following approach [B], explained above
            }
            
            // function to display the queue elements
            void Queue :: display()
            {
                int i;
                for( i = front; i &lt;= rear; i++)
                {
                    cout &lt;&lt; a[i] &lt;&lt; endl;
                }
            }
            
            // the main function
            int main()
            {
                Queue q;
                q.enqueue(10);
                q.enqueue(100);
                q.enqueue(1000);
                q.enqueue(1001);
                q.enqueue(1002);
                q.dequeue();
                q.enqueue(1003);
                q.dequeue();
                q.dequeue();
                q.enqueue(1004);
                
                q.display();
                
                return 0;
            }</pre></div><div class="element my-4"><h5>Implementation</h5><p>Queue can be implemented using an Array, Stack or Linked List. The easiest way of implementing a queue is by using an Array.
                
                Initially the head(FRONT) and the tail(REAR) of the queue points at the first index of the array (starting the index of array from 0). As we add elements to the queue, the tail keeps on moving ahead, always pointing to the position where the next element will be inserted, while the head remains at the first index.
                
                When we remove an element from Queue, we can follow two possible approaches (mentioned [A] and [B] in above diagram). In [A] approach, we remove the element at head position, and then one by one shift all the other elements in forward position.
                
                In approach [B] we remove the element from head position and then move head to the next position.
                
                In approach [A] there is an overhead of shifting the elements one position forward every time we remove the first element.
                
                In approach [B] there is no such overhead, but whenever we move head one position ahead, after removal of first element, the size on Queue is reduced by one space each time.</p></div><div class="element my-4"><img src="https://www.studytonight.com/data-structures/images/implementation-of-queue.png"></div><div class="element my-4"><h5>Complexity</h5><pre>Just like Stack, in case of a Queue too, we know exactly, on which position new element will be added and from where an element will be removed, hence both these operations requires a single step.
                    
                    Enqueue: O(1)
                    Dequeue: O(1)</pre></div>