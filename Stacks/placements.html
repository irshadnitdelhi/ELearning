
    <div>
        <pre>How to implement k stacks using an array ? 
                Create a data structure kStacks that represents k stacks. Implementation of kStacks should use only one array, i.e., k stacks should use the same array for storing elements. Following functions must be supported by kStacks.

                push(int x, int sn) –> pushes x to stack number ‘sn’ where sn is from 0 to k-1
                pop(int sn) –> pops an element from stack number ‘sn’ where sn is from 0 to k-1
        </pre>
        <pre>
                Method 1 (Divide the array in slots of size n/k)
                A simple way to implement k stacks is to divide the array in k slots of size n/k each, and fix the slots for different stacks, i.e., use arr[0] to arr[n/k-1] for first stack, and arr[n/k] to arr[2n/k-1] for stack2 where arr[] is the array to be used to implement two stacks and size of array be n.
                
                The problem with this method is inefficient use of array space. A stack push operation may result in stack overflow even if there is space available in arr[]. For example, say the k is 2 and array size (n) is 6 and we push 3 elements to first and do not push anything to second second stack. When we push 4th element to first, there will be overflow even if we have space for 3 more elements in array.
                
                Method 2 (A space efficient implementation)
                The idea is to use two extra arrays for efficient implementation of k stacks in an array. This may not make much sense for integer stacks, but stack items can be large for example stacks of employees, students, etc where every item is of hundreds of bytes. For such large stacks, the extra space used is comparatively very less as we use two integer arrays as extra space.
                
                Following are the two extra arrays are used:
                1) top[]: This is of size k and stores indexes of top elements in all stacks.
                2) next[]: This is of size n and stores indexes of next item for the items in array arr[]. Here arr[] is actual array that stores k stacks.
                Together with k stacks, a stack of free slots in arr[] is also maintained. The top of this stack is stored in a variable ‘free’.

                // A C++ program to demonstrate implementation of k stacks in a single 
            // array in time and space efficient way 
            #include<iostream> 
            #include<climits> 
            using namespace std; 

            // A C++ class to represent k stacks in a single array of size n 
            class kStacks 
            { 
                int *arr; // Array of size n to store actual content to be stored in stacks 
                int *top; // Array of size k to store indexes of top elements of stacks 
                int *next; // Array of size n to store next entry in all stacks 
                            // and free list 
                int n, k; 
                int free; // To store beginning index of free list 
            public: 
                //constructor to create k stacks in an array of size n 
                kStacks(int k, int n); 

                // A utility function to check if there is space available 
                bool isFull() { return (free == -1); } 

                // To push an item in stack number 'sn' where sn is from 0 to k-1 
                void push(int item, int sn); 

                // To pop an from stack number 'sn' where sn is from 0 to k-1 
                int pop(int sn); 

                // To check whether stack number 'sn' is empty or not 
                bool isEmpty(int sn) { return (top[sn] == -1); } 
            }; 

            //constructor to create k stacks in an array of size n 
            kStacks::kStacks(int k1, int n1) 
            { 
                // Initialize n and k, and allocate memory for all arrays 
                k = k1, n = n1; 
                arr = new int[n]; 
                top = new int[k]; 
                next = new int[n]; 

                // Initialize all stacks as empty 
                for (int i = 0; i < k; i++) 
                    top[i] = -1; 

                // Initialize all spaces as free 
                free = 0; 
                for (int i=0; i<n-1; i++) 
                    next[i] = i+1; 
                next[n-1] = -1; // -1 is used to indicate end of free list 
            } 

            // To push an item in stack number 'sn' where sn is from 0 to k-1 
            void kStacks::push(int item, int sn) 
            { 
                // Overflow check 
                if (isFull()) 
                { 
                    cout << "\nStack Overflow\n"; 
                    return; 
                } 

                int i = free;	 // Store index of first free slot 

                // Update index of free slot to index of next slot in free list 
                free = next[i]; 

                // Update next of top and then top for stack number 'sn' 
                next[i] = top[sn]; 
                top[sn] = i; 

                // Put the item in array 
                arr[i] = item; 
            } 

            // To pop an from stack number 'sn' where sn is from 0 to k-1 
            int kStacks::pop(int sn) 
            { 
                // Underflow check 
                if (isEmpty(sn)) 
                { 
                    cout << "\nStack Underflow\n"; 
                    return INT_MAX; 
                } 


                // Find index of top item in stack number 'sn' 
                int i = top[sn]; 

                top[sn] = next[i]; // Change top to store next of previous top 

                // Attach the previous top to the beginning of free list 
                next[i] = free; 
                free = i; 

                // Return the previous top item 
                return arr[i]; 
            } 

            /* Driver program to test twStacks class */
            int main() 
            { 
                // Let us create 3 stacks in an array of size 10 
                int k = 3, n = 10; 
                kStacks ks(k, n); 

                // Let us put some items in stack number 2 
                ks.push(15, 2); 
                ks.push(45, 2); 

                // Let us put some items in stack number 1 
                ks.push(17, 1); 
                ks.push(49, 1); 
                ks.push(39, 1); 

                // Let us put some items in stack number 0 
                ks.push(11, 0); 
                ks.push(9, 0); 
                ks.push(7, 0); 

                cout << "Popped element from stack 2 is " << ks.pop(2) << endl; 
                cout << "Popped element from stack 1 is " << ks.pop(1) << endl; 
                cout << "Popped element from stack 0 is " << ks.pop(0) << endl; 

                return 0; 
            } 

            
        </pre>

    </div>
    <div>
        <pre>How to create mergable stack?
                Design a stack with following operations.

                a) push(Stack s, x): Adds an item x to stack s
                b) pop(Stack s): Removes the top item from stack s
                c) merge(Stack s1, Stack s2): Merge contents of s2 into s1.
        </pre>
        <pre>

                If we use array implementation of stack, then merge is not possible to do in O(1) time as we have to do following steps.
                a) Delete old arrays
                b) Create a new array for s1 with size equal to size of old array for s1 plus size of s2.
                c) Copy old contents of s1 and s2 to new array for s1
                The above operations take O(n) time.
                
                We can use a linked list with two pointers, one pointer to first node (also used as top when elements are added and removed from beginning). The other pointer is needed for last node so that we can quickly link the linked list of s2 at the end of s1. Following are all operations.
                a) push(): Adds the new item at the beginning of linked list using first pointer.
                b) pop(): Removes an item from beginning using first pointer.
                c) merge(): Links the first pointer second stack as next of last pointer of first list.
                
                Can we do it if we are not allowed to use extra pointer?
                We can do it with circular linked list. The idea is to keep track of last node in linked list. The next of last node indicates top of stack.
                a) push(): Adds the new item as next of last node.
                b) pop(): Removes next of last node.
                c) merge(): Links the top (next of last) of second list to the top (next of last) of first list. And makes last of second list as last of whole list.

        </pre>

    </div>
    <div>
        <pre>
                Design a Data Structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() which should return minimum element from the SpecialStack. All these operations of SpecialStack must be O(1). To implement SpecialStack, you should only use standard Stack data structure and no other data structure like arrays, list, .. etc. 
        </pre>
        <pre>
                An approach that uses O(1) time and O(n) extra space is discussed here.

                In this article, a new approach is discussed that supports minimum with O(1) extra space. We define a variable minEle that stores the current minimum element in the stack. Now the interesting part is, how to handle the case when minimum element is removed. To handle this, we push “2x – minEle” into the stack instead of x so that previous minimum element can be retrieved using current minEle and its value stored in stack. Below are detailed steps and explanation of working.
                
                Push(x) : Inserts x at the top of stack.
                
                    If stack is empty, insert x into the stack and make minEle equal to x.
                    If stack is not empty, compare x with minEle. Two cases arise:
                        If x is greater than or equal to minEle, simply insert x.
                        If x is less than minEle, insert (2*x – minEle) into the stack and make minEle equal to x. For example, let previous minEle was 3. Now we want to insert 2. We update minEle as 2 and insert 2*2 – 3 = 1 into the stack.
                
                Pop() : Removes an element from top of stack.
                
                    Remove element from top. Let the removed element be y. Two cases arise:
                        If y is greater than or equal to minEle, the minimum element in the stack is still minEle.
                        If y is less than minEle, the minimum element now becomes (2*minEle – y), so update (minEle = 2*minEle – y). This is where we retrieve previous minimum from current minimum and its value in stack. For example, let the element to be removed be 1 and minEle be 2. We remove 1 and update minEle as 2*2 – 1 = 3.
                
        </pre>
    </div>
    <div>
        <pre>
                Design a Data Structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() which should return minimum element from the SpecialStack. All these operations of SpecialStack must be O(1). To implement SpecialStack, you should only use standard Stack data structure and no other data structure like arrays, list, .. etc. 
        </pre>
        <pre>
                An approach that uses O(1) time and O(n) extra space is discussed here.

                In this article, a new approach is discussed that supports minimum with O(1) extra space. We define a variable minEle that stores the current minimum element in the stack. Now the interesting part is, how to handle the case when minimum element is removed. To handle this, we push “2x – minEle” into the stack instead of x so that previous minimum element can be retrieved using current minEle and its value stored in stack. Below are detailed steps and explanation of working.
                
                Push(x) : Inserts x at the top of stack.
                
                    If stack is empty, insert x into the stack and make minEle equal to x.
                    If stack is not empty, compare x with minEle. Two cases arise:
                        If x is greater than or equal to minEle, simply insert x.
                        If x is less than minEle, insert (2*x – minEle) into the stack and make minEle equal to x. For example, let previous minEle was 3. Now we want to insert 2. We update minEle as 2 and insert 2*2 – 3 = 1 into the stack.
                
                Pop() : Removes an element from top of stack.
                
                    Remove element from top. Let the removed element be y. Two cases arise:
                        If y is greater than or equal to minEle, the minimum element in the stack is still minEle.
                        If y is less than minEle, the minimum element now becomes (2*minEle – y), so update (minEle = 2*minEle – y). This is where we retrieve previous minimum from current minimum and its value in stack. For example, let the element to be removed be 1 and minEle be 2. We remove 1 and update minEle as 2*2 – 1 = 3.
                
                Important Points:
                
                    Stack doesn’t hold actual value of an element if it is minimum so far.
                    Actual minimum element is always stored in minEle
                
                    // C++ program to implement a stack that supports 
                    // getMinimum() in O(1) time and O(1) extra space. 
                    #include <bits/stdc++.h> 
                    using namespace std; 
                    
                    // A user defined stack that supports getMin() in 
                    // addition to push() and pop() 
                    struct MyStack 
                    { 
                        stack<int> s; 
                        int minEle; 
                    
                        // Prints minimum element of MyStack 
                        void getMin() 
                        { 
                            if (s.empty()) 
                                cout << "Stack is empty\n"; 
                    
                            // variable minEle stores the minimum element 
                            // in the stack. 
                            else
                                cout <<"Minimum Element in the stack is: "
                                    << minEle << "\n"; 
                        } 
                    
                        // Prints top element of MyStack 
                        void peek() 
                        { 
                            if (s.empty()) 
                            { 
                                cout << "Stack is empty "; 
                                return; 
                            } 
                    
                            int t = s.top(); // Top element. 
                    
                            cout << "Top Most Element is: "; 
                    
                            // If t < minEle means minEle stores 
                            // value of t. 
                            (t < minEle)? cout << minEle: cout << t; 
                        } 
                    
                        // Remove the top element from MyStack 
                        void pop() 
                        { 
                            if (s.empty()) 
                            { 
                                cout << "Stack is empty\n"; 
                                return; 
                            } 
                    
                            cout << "Top Most Element Removed: "; 
                            int t = s.top(); 
                            s.pop(); 
                    
                            // Minimum will change as the minimum element 
                            // of the stack is being removed. 
                            if (t < minEle) 
                            { 
                                cout << minEle << "\n"; 
                                minEle = 2*minEle - t; 
                            } 
                    
                            else
                                cout << t << "\n"; 
                        } 
                    
                        // Removes top element from MyStack 
                        void push(int x) 
                        { 
                            // Insert new number into the stack 
                            if (s.empty()) 
                            { 
                                minEle = x; 
                                s.push(x); 
                                cout << "Number Inserted: " << x << "\n"; 
                                return; 
                            } 
                    
                            // If new number is less than minEle 
                            if (x < minEle) 
                            { 
                                s.push(2*x - minEle); 
                                minEle = x; 
                            } 
                    
                            else
                            s.push(x); 
                    
                            cout << "Number Inserted: " << x << "\n"; 
                        } 
                    }; 
                    
                    // Driver Code 
                    int main() 
                    { 
                        MyStack s; 
                        s.push(3); 
                        s.push(5); 
                        s.getMin(); 
                        s.push(2); 
                        s.push(1); 
                        s.getMin(); 
                        s.pop(); 
                        s.getMin(); 
                        s.pop(); 
                        s.peek(); 
                    
                        return 0; 
                    } 
                    
        </pre>
    </div>
    <div>
        <pre>Write an algorithm to convert infix to postfix expression</pre>
        <pre>
                1. Scan the infix expression from left to right.
                2. If the scanned character is an operand, output it.
                3. Else,
                …..3.1 If the precedence of the scanned operator is greater than the precedence of the operator in the stack(or the stack is empty or the stack contains a ‘(‘ ), push it.
                …..3.2 Else, Pop all the operators from the stack which are greater than or equal to in precedence than that of the scanned operator. After doing that Push the scanned operator to the stack. (If you encounter parenthesis while popping then stop there and push the scanned operator in the stack.)
                4. If the scanned character is an ‘(‘, push it to the stack.
                5. If the scanned character is an ‘)’, pop the stack and and output it until a ‘(‘ is encountered, and discard both the parenthesis.
                6. Repeat steps 2-6 until infix expression is scanned.
                7. Print the output
                8. Pop and output from the stack until it is not empty.
        </pre>
    </div>
    
</section>

